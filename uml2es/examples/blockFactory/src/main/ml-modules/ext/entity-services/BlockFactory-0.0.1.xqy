xquery version '1.0-ml';

(:
 This module was generated by MarkLogic Entity Services.
 The source model was BlockFactory-0.0.1

 For usage and extension points, see the Entity Services Developer's Guide

 https://docs.marklogic.com/guide/entity-services

 After modifying this file, put it in your project for deployment to the modules
 database of your application, and check it into your source control system.

 Generated at timestamp: 2018-04-04T09:12:18.558211-04:00
 :)

(:
IMPL Notes:
1. We add a big block comment with the facts of the extended ES model. Our code references this.
2. Most extract-instance functions are modified for source-to-target mapping.
3. We build the abbreviated, denormalized form of the block part. 
4. The signature for the extract-instance functions are enhanced. Newly added parameters are the content and context maps 
from MLCP. This allows the function to adjust URI, collections, perms, and other options of the document.

Here is the big comment:

Your model has the following extended facts. These facts are also saved as triples in your content DB:@prefix p7: <http://com.marlogic.es.umldemo.blockfactory/BlockFactory-0.0.1/BlockModelPart/> .
@prefix xs: <http://www.w3.org/2001/XMLSchema#> .
@prefix p0: <http://com.marlogic.es.umldemo.blockfactory/BlockFactory-0.0.1/> .
@prefix p5: <http://com.marlogic.es.umldemo.blockfactory/BlockFactory-0.0.1/CustomBlockModel/> .
@prefix p2: <http://com.marlogic.es.umldemo.blockfactory/BlockFactory-0.0.1/Block/> .
@prefix p4: <http://com.marlogic.es.umldemo.blockfactory/BlockFactory-0.0.1/BlockModel/> .
@prefix p1: <http://marklogic.com/xmi2es/xes#> .
@prefix p6: <http://com.marlogic.es.umldemo.blockfactory/BlockFactory-0.0.1/BlockColor/> .

p5:blocks       p1:reference    p0:BlockModelPart ;
                p1:relationship "composite" ;
                p1:typeIsReference
                                "true"^^xs:boolean .

p0:Block        p1:collections  "part" .

p0:BlockModel   p1:collections  "product" .

p4:blocks       p1:reference    p0:BlockModelPart ;
                p1:relationship "composite" ;
                p1:typeIsReference
                                "true"^^xs:boolean .

_:bnode4721720869404596580
                p1:associationClassEndAttribute
                                p6:alternatives ;
                p1:associationClassEndFK
                                "true"^^xs:boolean ;
                p1:associationClassEndClass
                                p0:BlockColor .

p6:alternatives p1:reference    p0:BlockColor ;
                p1:relationship "association" ;
                p1:typeIsReference
                                "true"^^xs:boolean ;
                p1:associationClass
                                p0:Similarity .

p4:instructions p1:reference    p0:Instructions ;
                p1:relationship "shared" ;
                p1:typeIsReference
                                "true"^^xs:boolean .

p2:material     p1:reference    p0:Material ;
                p1:relationship "association" ;
                p1:typeIsReference
                                "true"^^xs:boolean .

p5:instructions p1:reference    p0:Instructions ;
                p1:relationship "shared" ;
                p1:typeIsReference
                                "true"^^xs:boolean .

p5:clientRequester
                p1:reference    p0:Client ;
                p1:relationship "association" ;
                p1:typeIsReference
                                "true"^^xs:boolean .

p2:color        p1:reference    p0:BlockColor ;
                p1:relationship "association" ;
                p1:typeIsReference
                                "true"^^xs:boolean .

p0:Similarity   p1:hasAssociationClassEnd
                                _:bnode4721720869404596580 ;
                p1:isAssociationClass
                                "true"^^xs:boolean .

p7:blockSummary p1:reference    p0:Block ;
                p1:reminder     "abbrev and denorm" ;
                p1:relationship "association" ;
                p1:typeIsReference
                                "true"^^xs:boolean .

p0:CustomBlockModel
                p1:collections  "product" ,
                                "custom" ,
                                "product" ;
                p1:baseClass    p0:BlockModel .

:)


module namespace blockFactory
    = 'http://com.marlogic.es.umldemo.blockfactory#BlockFactory-0.0.1';

import module namespace es = 'http://marklogic.com/entity-services'
    at '/MarkLogic/entity-services/entity-services.xqy';

import module namespace json = "http://marklogic.com/xdmp/json"
    at "/MarkLogic/json/json.xqy";


declare option xdmp:mapping 'false';


(:~
 : Extracts instance data, as a map:map, from some source document.
 : @param $source-node  A document or node that contains
 :   data for populating a Block
 : @return A map:map instance with extracted data and
 :   metadata about the instance.
 :)
declare function blockFactory:extract-instance-Block(
    $source as item()?, $content as map:map, $context as map:map
) as map:map
{
    (: IMPL: source mapping, collections :)

    let $source-node := es:init-source($source, 'Block')
    let $blockNumber  :=             $source-node/blockNumber ! xs:string(.)
    let $length  :=             $source-node/length ! xs:float(.)
    let $width  :=             $source-node/width ! xs:float(.)
    let $height  :=             $source-node/height ! xs:float(.)
    let $mass  :=             $source-node/mass ! xs:float(.)
    let $color  :=             $source-node/colorCode ! xs:string(.)
    let $material  :=             $source-node/materialId ! xs:string(.) 
    let $instance := es:init-instance($source-node, 'Block')
    (: Comment or remove the following line to suppress attachments :)
        =>es:add-attachments($source)

    (: As per extension note above, we should add to "part" collection :)
    let $collections := map:get($context, "collections")
    let $_ := map:put($context, "collections", ($collections, "part"))

    return
    if (empty($source-node/*))
    then $instance
    else $instance
        =>   map:with('blockNumber', $blockNumber)
        =>   map:with('length', $length)
        =>   map:with('width', $width)
        =>   map:with('height', $height)
        =>   map:with('mass', $mass)
        =>   map:with('color', $color)
        =>   map:with('material', $material)
};

(:~
 : Extracts instance data, as a map:map, from some source document.
 : @param $source-node  A document or node that contains
 :   data for populating a Instructions
 : @return A map:map instance with extracted data and
 :   metadata about the instance.
 :)
declare function blockFactory:extract-instance-Instructions(
    $source as item()?
) as map:map
{
    let $source-node := es:init-source($source, 'Instructions')
    let $docURL  :=             $source-node/docURL ! xs:string(.)
    let $docReleaseTag  :=              $source-node/docReleaseTag ! xs:string(.) 
    let $instance := es:init-instance($source-node, 'Instructions')
    (: Comment or remove the following line to suppress attachments :)
        =>es:add-attachments($source)

    return
    if (empty($source-node/*))
    then $instance
    else $instance
        =>   map:with('docURL', $docURL)
        =>   map:with('docReleaseTag', $docReleaseTag)
};

(:~
 : Extracts instance data, as a map:map, from some source document.
 : @param $source-node  A document or node that contains
 :   data for populating a BlockModel
 : @return A map:map instance with extracted data and
 :   metadata about the instance.
 :)
declare function blockFactory:extract-instance-BlockModel(
    $source as item()?, $content as map:map, $context as map:map
) as map:map
{
    (: IMPL: collectons :)

    let $source-node := es:init-source($source, 'BlockModel')
    (: The following property is a local reference.  :)
    let $blocks  :=             es:extract-array($source-node/blocks, blockFactory:extract-instance-BlockModelPart#1)
    (: The following property is a local reference.  :)
    let $instructions  :=             $source-node/instructions ! blockFactory:extract-instance-Instructions(.)
    let $modelId  :=             $source-node/modelId ! xs:string(.)
    let $modelName  :=             $source-node/modelName ! xs:string(.) 
    let $instance := es:init-instance($source-node, 'BlockModel')
    (: Comment or remove the following line to suppress attachments :)
        =>es:add-attachments($source)

    (: As per extension note above, we should add to "product" collection :)
    let $collections := map:get($context, "collections")
    let $_ := map:put($context, "collections", ($collections, "product"))

    return
    if (empty($source-node/*))
    then $instance
    else $instance
        =>es:optional('blocks', $blocks)
        =>   map:with('instructions', $instructions)
        =>   map:with('modelId', $modelId)
        =>   map:with('modelName', $modelName)
};

(:~
 : Extracts instance data, as a map:map, from some source document.
 : @param $source-node  A document or node that contains
 :   data for populating a Client
 : @return A map:map instance with extracted data and
 :   metadata about the instance.
 :)
declare function blockFactory:extract-instance-Client(
    $source as item()?, $content as map:map, $context as map:map
) as map:map
{
    (: IMPL: source mapping changes :)

    let $source-node := es:init-source($source, 'Client')
    let $clientId  :=             $source-node/id ! xs:string(.)
    let $clientName  :=             $source-node/name ! xs:string(.)
    let $clientCountry  :=              $source-node/country ! xs:string(.) 
    let $instance := es:init-instance($source-node, 'Client')
    (: Comment or remove the following line to suppress attachments :)
        =>es:add-attachments($source)
    return
    if (empty($source-node/*))
    then $instance
    else $instance
        =>   map:with('clientId', $clientId)
        =>   map:with('clientName', $clientName)
        =>   map:with('clientCountry', $clientCountry)
};

(:~
 : Extracts instance data, as a map:map, from some source document.
 : @param $source-node  A document or node that contains
 :   data for populating a CustomBlockModel
 : @return A map:map instance with extracted data and
 :   metadata about the instance.
 :)
declare function blockFactory:extract-instance-CustomBlockModel(
    $source as item()?, $content as map:map, $context as map:map
) as map:map
{
    (: IMPL: source mappings, collections :)

    let $source-node := es:init-source($source, 'CustomBlockModel')
    let $clientRequester  :=                $source-node/clientId ! xs:string(.)
    let $requestDate  :=             $source-node/requestDate ! xs:date(.)
    let $completionDate  :=               $source-node/completionDate ! xs:date(.)
    let $status  :=             $source-node/status ! xs:string(.)
    (: The following property is a local reference.  :)
    let $blocks  :=             es:extract-array($source-node/blocks, blockFactory:extract-instance-BlockModelPart#1)
    (: The following property is a local reference.  :)
    let $instructions  :=             $source-node/instructions ! blockFactory:extract-instance-Instructions(.)
    let $modelId  :=             $source-node/modelId ! xs:string(.)
    let $modelName  :=             $source-node/modelName ! xs:string(.) 
    let $instance := es:init-instance($source-node, 'CustomBlockModel')
    (: Comment or remove the following line to suppress attachments :)
        =>es:add-attachments($source)

    (: As per extension note above, we should add to "product" and "custom" collections :)
    let $collections := map:get($context, "collections")
    let $_ := map:put($context, "collections", ($collections, "product", "custom"))

    return
    if (empty($source-node/*))
    then $instance
    else $instance
        =>   map:with('clientRequester', $clientRequester)
        =>   map:with('requestDate', $requestDate)
        =>es:optional('completionDate', $completionDate)
        =>   map:with('status', $status)
        =>es:optional('blocks', $blocks)
        =>   map:with('instructions', $instructions)
        =>   map:with('modelId', $modelId)
        =>   map:with('modelName', $modelName)
};

(:~
 : Extracts instance data, as a map:map, from some source document.
 : @param $source-node  A document or node that contains
 :   data for populating a BlockColor
 : @return A map:map instance with extracted data and
 :   metadata about the instance.
 :)
declare function blockFactory:extract-instance-BlockColor(
    $source as item()?, $content as map:map, $context as map:map
) as map:map
{
    let $source-node := es:init-source($source, 'BlockColor')
    let $colorCode  :=             $source-node/colorCode ! xs:string(.)
    let $rgbString  :=             $source-node/rgbString ! xs:string(.)
    let $name  :=             $source-node/name ! xs:string(.)
    (: The following property is a local reference.  :)
    let $alternatives  :=             es:extract-array($source-node/alternatives, blockFactory:extract-instance-Similarity#1)
    let $rgb  :=             json:to-array($source-node/rgb ! xs:int(.) )
    let $cie  :=             json:to-array($source-node/cie ! xs:float(.) )
    let $hue  :=             $source-node/hue ! xs:string(.)
    let $saturation  :=             $source-node/saturation ! xs:string(.)
    let $brightness  :=             $source-node/brightness ! xs:string(.) 
    let $instance := es:init-instance($source-node, 'BlockColor')
    (: Comment or remove the following line to suppress attachments :)
        =>es:add-attachments($source)

    return
    if (empty($source-node/*))
    then $instance
    else $instance
        =>   map:with('colorCode', $colorCode)
        =>   map:with('rgbString', $rgbString)
        =>   map:with('name', $name)
        =>es:optional('alternatives', $alternatives)
        =>   map:with('rgb', $rgb)
        =>   map:with('cie', $cie)
        =>   map:with('hue', $hue)
        =>   map:with('saturation', $saturation)
        =>   map:with('brightness', $brightness)
};

(:~
 : Extracts instance data, as a map:map, from some source document.
 : @param $source-node  A document or node that contains
 :   data for populating a BlockModelPart
 : @return A map:map instance with extracted data and
 :   metadata about the instance.
 :)
declare function blockFactory:extract-instance-BlockModelPart(
    $source as item()?
) as map:map
{
    (: IMPL: this is where we do the abbreviate and denorm :)

    (: grab the block, material, color :)
    let $source-node := es:init-source($source, 'BlockModelPart')
    let $block := fn:doc(concat("/xmi2es/blockFactory/block/", $source-node/blockNumber, ".json"))/envelope/instance/Block
    let $material := fn:doc(concat("/xmi2es/blockFactory/material/", $block/material, ".json"))/envelope/instance/Material
    let $color := fn:doc(concat("/xmi2es/blockFactory/color/", $block/color, ".json"))/envelope/instance/BlockColor
    let $_ :=
        if (not(exists($block)) or not(exists($material)) or not(exists($color))) then
            xdmp:log(concat("Unable to resolve structure of block *", $source-node/blockNumber, "*"), "error")
        else ()

    let $quantity  :=             $source-node/quantity ! xs:int(.)
    let $blockNumber  :=          $source-node/blockNumber ! xs:string(.)
    let $blockDim := concat($block/length, "x", $block/width, "x", $block/height) ! xs:string(.)
    let $materialId  :=          $material/materialId ! xs:string(.)
    let $materialName  :=          $material/materialName ! xs:string(.)
    let $materialType  :=          $material/materialType ! xs:string(.)
    let $colorCode  :=          $color/colorCode ! xs:string(.)
    let $colorName  :=          $color/name ! xs:string(.)
    let $closestColor := $color/alternatives[1]/Similarity/refBlockColor ! xs:string(.)
    let $closestColorName := fn:doc(concat("/xmi2es/blockFactory/color/", $closestColor, ".json"))/envelope/instance/BlockColor/name ! xs:string(.)

    let $instance := es:init-instance($source-node, 'BlockModelPart')
    (: Comment or remove the following line to suppress attachments :)
        =>es:add-attachments($source)

    return
    if (empty($source-node/*))
    then $instance
    else $instance
        =>   map:with('quantity', $quantity)
        =>   map:with('blockNumber', $blockNumber)
        =>es:optional('blockDim', $blockDim)
        =>es:optional('materialId', $materialId)
        =>es:optional('materialName', $materialName)
        =>es:optional('materialType', $materialType)
        =>es:optional('colorCode', $colorCode)
        =>es:optional('colorName', $colorName)
        =>es:optional('closestColor', $closestColor)
        =>es:optional('closestColorName', $closestColorName)
};

(:~
 : Extracts instance data, as a map:map, from some source document.
 : @param $source-node  A document or node that contains
 :   data for populating a Material
 : @return A map:map instance with extracted data and
 :   metadata about the instance.
 :)
declare function blockFactory:extract-instance-Material(
    $source as item()?, $content as map:map, $context as map:map
) as map:map
{
    (: IMPL: source mapping changes :)
    let $source-node := es:init-source($source, 'Material')
    let $materialId  :=             $source-node/id ! xs:string(.)
    let $materialName  :=             $source-node/name ! xs:string(.)
    let $materialType  :=             $source-node/type ! xs:string(.) 
    let $instance := es:init-instance($source-node, 'Material')
    (: Comment or remove the following line to suppress attachments :)
        =>es:add-attachments($source)

    return
    if (empty($source-node/*))
    then $instance
    else $instance
        =>   map:with('materialId', $materialId)
        =>   map:with('materialName', $materialName)
        =>   map:with('materialType', $materialType)
};

(:~
 : Extracts instance data, as a map:map, from some source document.
 : @param $source-node  A document or node that contains
 :   data for populating a Similarity
 : @return A map:map instance with extracted data and
 :   metadata about the instance.
 :)
declare function blockFactory:extract-instance-Similarity(
    $source as item()?
) as map:map
{
    (: IMPL: source mapping :)

    let $source-node := es:init-source($source, 'Similarity')
    let $score  :=             $source-node/score ! xs:float(.)
    let $refBlockColor  :=     $source-node/colorCode ! xs:string(.)
    let $instance := es:init-instance($source-node, 'Similarity')
    (: Comment or remove the following line to suppress attachments :)
        =>es:add-attachments($source)

    return
    if (empty($source-node/*))
    then $instance
    else $instance
        =>   map:with('score', $score)
        =>   map:with('refBlockColor', $refBlockColor)
};


(:~
 : Turns an entity instance into a canonical document structure.
 : Results in either a JSON document, or an XML document that conforms
 : to the entity-services schema.
 : Using this function as-is should be sufficient for most use
 : cases, and will play well with other generated artifacts.
 : @param $entity-instance A map:map instance returned from one of the extract-instance
 :    functions.
 : @param $format Either "json" or "xml". Determines output format of function
 : @return An XML element that encodes the instance.
 :)
declare function blockFactory:instance-to-canonical(

    $entity-instance as map:map,
    $instance-format as xs:string
) as node()
{

        if ($instance-format eq "json")
        then xdmp:to-json( blockFactory:canonicalize($entity-instance) )/node()
        else blockFactory:instance-to-canonical-xml($entity-instance)
};


(:~
 : helper function to turn map structure of an instance, which uses specialized
 : keys to encode metadata, into a document tree, which uses the node structure
 : to encode all type and property information.
 :)
declare private function blockFactory:canonicalize(
    $entity-instance as map:map
) as map:map
{
    json:object()
    =>map:with( map:get($entity-instance,'$type'),
                if ( map:contains($entity-instance, '$ref') )
                then fn:head( (map:get($entity-instance, '$ref'), json:object()) )
                else
                let $m := json:object()
                let $_ :=
                    for $key in map:keys($entity-instance)
                    let $instance-property := map:get($entity-instance, $key)
                    where ($key castable as xs:NCName)
                    return
                        typeswitch ($instance-property)
                        (: This branch handles embedded objects.  You can choose to prune
                           an entity's representation of extend it with lookups here. :)
                        case json:object
                            return
                                if (empty(map:keys($instance-property)))
                                then map:put($m, $key, json:object())
                                else map:put($m, $key, blockFactory:canonicalize($instance-property))
                        (: An array can also treated as multiple elements :)
                        case json:array
                            return
                                (
                                for $val at $i in json:array-values($instance-property)
                                return
                                    if ($val instance of json:object)
                                    then json:set-item-at($instance-property, $i, blockFactory:canonicalize($val))
                                    else (),
                                map:put($m, $key, $instance-property)
                                )

                        (: A sequence of values should be simply treated as multiple elements :)
                        (: TODO is this lossy? :)
                        case item()+
                            return
                                for $val in $instance-property
                                return map:put($m, $key, $val)
                        default return map:put($m, $key, $instance-property)
                return $m)
};





(:~
 : Turns an entity instance into an XML structure.
 : This out-of-the box implementation traverses a map structure
 : and turns it deterministically into an XML tree.
 : Using this function as-is should be sufficient for most use
 : cases, and will play well with other generated artifacts.
 : @param $entity-instance A map:map instance returned from one of the extract-instance
 :    functions.
 : @return An XML element that encodes the instance.
 :)
declare private function blockFactory:instance-to-canonical-xml(
    $entity-instance as map:map
) as element()
{
    (: Construct an element that is named the same as the Entity Type :)
    let $namespace := map:get($entity-instance, "$namespace")
    let $namespace-prefix := map:get($entity-instance, "$namespacePrefix")
    let $nsdecl :=
        if ($namespace) then
        namespace { $namespace-prefix } { $namespace }
        else ()
    let $type-name := map:get($entity-instance, '$type')
    let $type-qname :=
        if ($namespace)
        then fn:QName( $namespace, $namespace-prefix || ":" || $type-name)
        else $type-name
    return
        element { $type-qname }  {
            $nsdecl,
            if ( map:contains($entity-instance, '$ref') )
            then map:get($entity-instance, '$ref')
            else
                for $key in map:keys($entity-instance)
                let $instance-property := map:get($entity-instance, $key)
                let $ns-key :=
                    if ($namespace and $key castable as xs:NCName)
                    then fn:QName( $namespace, $namespace-prefix || ":" || $key)
                    else $key
                where ($key castable as xs:NCName)
                return
                    typeswitch ($instance-property)
                    (: This branch handles embedded objects.  You can choose to prune
                       an entity's representation of extend it with lookups here. :)
                    case json:object+
                        return
                            for $prop in $instance-property
                            return element { $ns-key } { blockFactory:instance-to-canonical-xml($prop) }
                    (: An array can also treated as multiple elements :)
                    case json:array
                        return
                            for $val in json:array-values($instance-property)
                            return
                                if ($val instance of json:object)
                                then element { $ns-key } {
                                    attribute datatype { 'array' },
                                    blockFactory:instance-to-canonical-xml($val)
                                }
                                else element { $ns-key } {
                                    attribute datatype { 'array' },
                                    $val }
                    (: A sequence of values should be simply treated as multiple elements :)
                    case item()+
                        return
                            for $val in $instance-property
                            return element { $ns-key } { $val }
                    default return element { $ns-key } { $instance-property }
        }
};


(:
 : Wraps a canonical instance (returned by instance-to-canonical())
 : within an envelope patterned document, along with the source
 : document, which is stored in an attachments section.
 : @param $entity-instance an instance, as returned by an extract-instance
 : function
 : @param $entity-format Either "json" or "xml", selects the output format
 : for the envelope
 : @return A document which wraps both the canonical instance and source docs.
 :)
declare function blockFactory:instance-to-envelope(
    $entity-instance as map:map,
    $envelope-format as xs:string
) as document-node()
{
    let $canonical := blockFactory:instance-to-canonical($entity-instance, $envelope-format)
    let $attachments := es:serialize-attachments($entity-instance, $envelope-format)
    return
    if ($envelope-format eq "xml")
    then
        document {
            element es:envelope {
                element es:instance {
                    element es:info {
                        element es:title { map:get($entity-instance,'$type') },
                        element es:version { '0.0.1' }
                    },
                    $canonical
                },
                $attachments
            }
        }
    else
    document {
        object-node { 'envelope' :
            object-node { 'instance' :
                object-node { 'info' :
                    object-node {
                        'title' : map:get($entity-instance,'$type'),
                        'version' : '0.0.1'
                    }
                }
                +
                $canonical
            }
            +
            $attachments
        }
    }
};


(:
 : @param $entity-instance an instance, as returned by an extract-instance
 : function
 : @return A document which wraps both the canonical instance and source docs.
 :)
declare function blockFactory:instance-to-envelope(
    $entity-instance as map:map
) as document-node()
{
    blockFactory:instance-to-envelope($entity-instance, "xml")
};



